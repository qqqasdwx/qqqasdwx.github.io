<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【转】goroutine与调度器]]></title>
    <url>%2F2018%2F11%2F12%2F54f16b95.html</url>
    <content type="text"><![CDATA[简介 我们都知道Go语言是原生支持语言级并发的，这个并发的最小逻辑单元就是goroutine。 goroutine就是Go语言提供的一种用户态线程，当然这种用户态线程是跑在内核级线程之上的。 当我们创建了很多的goroutine，并且它们都是跑在同一个内核线程之上的时候，就需要一个调度器来维护这些goroutine，确保所有的goroutine都使用cpu，并且是尽可能公平的使用cpu资源。 声明 本文转载自goroutine与调度器 想看原文请自行跳转 以下为原文基本概念 这个调度器的原理以及实现值得我们去深入研究一下。支撑整个调度器的主要有4个重要结构，分别是M、G、P、Sched，前三个定义在runtime.h中，Sched定义在proc.c中。 Sched结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。 M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。 P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine，这个P的角色可能有一点让人迷惑，一开始容易和M冲突，后面重点聊一下它们的关系。 G就是goroutine实现的核心结构了，G维护了goroutine需要的栈、程序计数器以及它所在的M等信息。理解M、P、G三者的关系对理解整个调度器非常重要，我从网络上找了一个图来说明其三者关系： 地鼠(gopher)用小车运着一堆待加工的砖。M就可以看作图中的地鼠，P就是小车，G就是小车里装的砖。一图胜千言啊，弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。 启动过程在关心绝大多数程序的内部原理的时候，我们都试图去弄明白其启动初始化过程，弄明白这个过程对后续的深入分析至关重要。在asm_amd64.s文件中的汇编代码_rt0_amd64就是整个启动过程，核心过程如下： 1234567891011121314CALL runtime·args(SB)CALL runtime·osinit(SB)CALL runtime·hashinit(SB)CALL runtime·schedinit(SB)// create a new goroutine to start programPUSHQ $runtime·main·f(SB) // entryPUSHQ $0 // arg sizeCALL runtime·newproc(SB)POPQ AXPOPQ AX// start this MCALL runtime·mstart(SB) 启动过程做了调度器初始化runtime·schedinit后，调用runtime·newproc创建出第一个goroutine，这个goroutine将执行的函数是runtime·main，这第一个goroutine也就是所谓的主goroutine。我们写的最简单的Go程序”hello，world”就是完全跑在这个goroutine里，当然任何一个Go程序的入口都是从这个goroutine开始的。最后调用的runtime·mstart就是真正的执行上一步创建的主goroutine。 启动过程中的调度器初始化runtime·schedinit函数主要根据用户设置的GOMAXPROCS值来创建一批小车(P)，不管GOMAXPROCS设置为多大，最多也只能创建256个小车(P)。这些小车(p)初始创建好后都是闲置状态，也就是还没开始使用，所以它们都放置在调度器结构(Sched)的pidle字段维护的链表中存储起来了，以备后续之需。 查看runtime·main函数可以了解到主goroutine开始执行后，做的第一件事情是创建了一个新的内核线程(地鼠M)，不过这个线程是一个特殊线程，它在整个运行期专门负责做特定的事情——系统监控(sysmon)。接下来就是进入Go程序的main函数开始Go程序的执行。 至此，Go程序就被启动起来开始运行了。一个真正干活的Go程序，一定创建有不少的goroutine，所以在Go程序开始运行后，就会向调度器添加goroutine，调度器就要负责维护好这些goroutine的正常执行。 创建goroutine(G)在Go程序中，时常会有类似代码： 1go do_something() go关键字就是用来创建一个goroutine的，后面的函数就是这个goroutine需要执行的代码逻辑。go关键字对应到调度器的接口就是runtime·newproc。runtime·newproc干的事情很简单，就负责制造一块砖(G)，然后将这块砖(G)放入当前这个地鼠(M)的小车(P)中。 每个新的goroutine都需要有一个自己的栈，G结构的sched字段维护了栈地址以及程序计数器等信息，这是最基本的调度信息，也就是说这个goroutine放弃cpu的时候需要保存这些信息，待下次重新获得cpu的时候，需要将这些信息装载到对应的cpu寄存器中。 假设这个时候已经创建了大量的goroutne，就轮到调度器去维护这些goroutine了。 创建内核线程(M) Go程序中没有语言级的关键字让你去创建一个内核线程，你只能创建goroutine，内核线程只能由runtime根据实际情况去创建。runtime什么时候创建线程？以地鼠运砖图来讲，砖(G)太多了，地鼠(M)又太少了，实在忙不过来，刚好还有空闲的小车(P)没有使用，那就从别处再借些地鼠(M)过来直到把小车(p)用完为止。这里有一个地鼠(M)不够用，从别处借地鼠(M)的过程，这个过程就是创建一个内核线程(M)。创建M的接口函数是: 1void newm(void (*fn)(void), P *p) newm函数的核心行为就是调用clone系统调用创建一个内核线程，每个内核线程的开始执行位置都是runtime·mstart函数。参数p就是一辆空闲的小车(p)。 每个创建好的内核线程都从runtime·mstart函数开始执行了，它们将用分配给自己小车去搬砖了。 调度核心newm接口只是给新创建的M分配了一个空闲的P，也就是相当于告诉借来的地鼠(M)——“接下来的日子，你将使用1号小车搬砖，记住是1号小车；待会自己到停车场拿车。”，地鼠(M)去拿小车(P)这个过程就是acquirep。runtime·mstart在进入schedule之前会给当前M装配上P，runtime·mstart函数中的代码： 12345&#125; else if(m != &amp;runtime·m0) &#123; acquirep(m-&gt;nextp); m-&gt;nextp = nil;&#125;schedule(); if分支的内容就是为当前M装配上P，nextp就是newm分配的空闲小车(P)，只是到这个时候才真正拿到手罢了。没有P，M是无法执行goroutine的，就像地鼠没有小车无法运砖一样的道理。对应acquirep的动作是releasep，把M装配的P给载掉；活干完了，地鼠需要休息了，就把小车还到停车场，然后睡觉去。 地鼠(M)拿到属于自己的小车(P)后，就进入工场开始干活了，也就是上面的schedule调用。简化schedule的代码如下： 12345678910111213141516static voidschedule(void)&#123; G *gp; gp = runqget(m-&gt;p); if(gp == nil) gp = findrunnable(); if (m-&gt;p-&gt;runqhead != m-&gt;p-&gt;runqtail &amp;&amp; runtime·atomicload(&amp;runtime·sched.nmspinning) == 0 &amp;&amp; runtime·atomicload(&amp;runtime·sched.npidle) &gt; 0) // TODO: fast atomic wakep(); execute(gp);&#125; schedule函数被我简化了太多，主要是我不喜欢贴大段大段的代码，因此只保留主干代码了。这里涉及到4大步逻辑： runqget, 地鼠(M)试图从自己的小车(P)取出一块砖(G)，当然结果可能失败，也就是这个地鼠的小车已经空了，没有砖了。 findrunnable, 如果地鼠自己的小车中没有砖，那也不能闲着不干活是吧，所以地鼠就会试图跑去工场仓库取一块砖来处理；工场仓库也可能没砖啊，出现这种情况的时候，这个地鼠也没有偷懒停下干活，而是悄悄跑出去，随机盯上一个小伙伴(地鼠)，然后从它的车里试图偷一半砖到自己车里。如果多次尝试偷砖都失败了，那说明实在没有砖可搬了，这个时候地鼠就会把小车还回停车场，然后睡觉休息了。如果地鼠睡觉了，下面的过程当然都停止了，地鼠睡觉也就是线程sleep了。 wakep, 到这个过程的时候，可怜的地鼠发现自己小车里有好多砖啊，自己根本处理不过来；再回头一看停车场居然有闲置的小车，立马跑到宿舍一看，你妹，居然还有小伙伴在睡觉，直接给屁股一脚，“你妹，居然还在睡觉，老子都快累死了，赶紧起来干活，分担点工作。”，小伙伴醒了，拿上自己的小车，乖乖干活去了。有时候，可怜的地鼠跑到宿舍却发现没有在睡觉的小伙伴，于是会很失望，最后只好向工场老板说——”停车场还有闲置的车啊，我快干不动了，赶紧从别的工场借个地鼠来帮忙吧。”，最后工场老板就搞来一个新的地鼠干活了。 execute，地鼠拿着砖放入火种欢快的烧练起来。 注： “地鼠偷砖”叫work stealing，一种调度算法。 到这里，貌似整个工场都正常的运转起来了，无懈可击的样子。不对，还有一个疑点没解决啊，假设地鼠的车里有很多砖，它把一块砖放入火炉中后，何时把它取出来，放入第二块砖呢？难道要一直把第一块砖烧练好，才取出来吗？那估计后面的砖真的是等得花儿都要谢了。这里就是要真正解决goroutine的调度，上下文切换问题。 调度点当我们翻看channel的实现代码可以发现，对channel读写操作的时候会触发调用runtime·park函数。goroutine调用park后，这个goroutine就会被设置位waiting状态，放弃cpu。被park的goroutine处于waiting状态，并且这个goroutine不在小车(P)中，如果不对其调用runtime·ready，它是永远不会再被执行的。除了channel操作外，定时器中，网络poll等都有可能park goroutine。 除了park可以放弃cpu外，调用runtime·gosched函数也可以让当前goroutine放弃cpu，但和park完全不同；gosched是将goroutine设置为runnable状态，然后放入到调度器全局等待队列（也就是上面提到的工场仓库，这下就明白为何工场仓库会有砖块(G)了吧）。 除此之外，就轮到系统调用了，有些系统调用也会触发重新调度。Go语言完全是自己封装的系统调用，所以在封装系统调用的时候，可以做不少手脚，也就是进入系统调用的时候执行entersyscall，退出后又执行exitsyscall函数。 也只有封装了entersyscall的系统调用才有可能触发重新调度，它将改变小车(P)的状态为syscall。还记一开始提到的sysmon线程吗？这个系统监控线程会扫描所有的小车(P)，发现一个小车(P)处于了syscall的状态，就知道这个小车(P)遇到了goroutine在做系统调用，于是系统监控线程就会创建一个新的地鼠(M)去把这个处于syscall的小车给抢过来，开始干活，这样这个小车中的所有砖块(G)就可以绕过之前系统调用的等待了。被抢走小车的地鼠等系统调用返回后，发现自己的车没，不能继续干活了，于是只能把执行系统调用的goroutine放回到工场仓库，自己睡觉去了。 从goroutine的调度点可以看出，调度器还是挺粗暴的，调度粒度有点过大，公平性也没有想想的那么好。总之，这个调度器还是比较简单的。 现场处理goroutine在cpu上换入换出，不断上下文切换的时候，必须要保证的事情就是保存现场和恢复现场，保存现场就是在goroutine放弃cpu的时候，将相关寄存器的值给保存到内存中；恢复现场就是在goroutine重新获得cpu的时候，需要从内存把之前的寄存器信息全部放回到相应寄存器中去。 goroutine在主动放弃cpu的时候(park/gosched)，都会涉及到调用runtime·mcall函数，此函数也是汇编实现，主要将goroutine的栈地址和程序计数器保存到G结构的sched字段中，mcall就完成了现场保存。恢复现场的函数是runtime·gogocall，这个函数主要在execute中调用，就是在执行goroutine前，需要重新装载相应的寄存器。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程、线程、协程与goroutine]]></title>
    <url>%2F2018%2F11%2F11%2F7dbd20a3.html</url>
    <content type="text"><![CDATA[简介 相信作为服务端开发尤其是高性能服务开发的猿们，曾经面试都曾经被问到进程，线程之类的问题，作为操作系统最核心的概念，这些X程就像我们的一个个工具，是我们在开发过程中经常接触的概念 对于这些概念的不清晰我们便发现写的代码功能是对的，代码是渣的，将直接体现在我们代码的低效率，高bug率并附带问题出现都不知到问题出在哪里 作为新时代的猿我们原不需要那么多时间去解bug，我们需要更多时间陪女票，不是吗？ 声明 本文参考自 Go runtime的调度器 进程、线程、协程与goroutine goroutine 进程、线程、轻量级进程、协程和go中的Goroutine 那些事儿 由本文作者整理，想看原文请自行跳转 正文基本概念 进程：独立的栈空间，独立的堆空间，进程之间调度由os完成。 线程：独立的栈空间，共享堆空间，内核线程之间调度由os完成。 协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 同步调用：就是由调用者主动等待这个调用的结果。发出一个调用，在没有得到结果之前，该调用就不返回。一旦调用返回，就得到返回值了。 异步调用：调用在发出之后，这个调用结果就直接返回了。当一个异步调用过程在发出之后，调用者不会立即得到结果，而是在调用发出后，被调用者通过状态、通知来通知调用者，或者通过函数回调来处理这个调用。 阻塞与非阻塞：关注的是:程序在等待调用结果（消息 返回值）时的状态 阻塞调用：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 非阻塞调用：是指，在不能立刻得到结果之前，该调用不会阻塞当前线程，当前线程还会继续执行下去。 协程 协程的概念其实比线程还要早，不过是这几年才被大家熟知，线程在实现上可以说是一个特化的1:N协程。 协程的核心机制是什么？ 学过汇编的童鞋应该记得实模式编程下，理论上操作系统只能加载一个进程，那个时候进程要使用系统服务的方法非常简单，就是手工产生一个中断，然后我们就知道了会触发CPU的中断处理机制，会保护好发起中断的现场，然后会将当前执行地址设置为对应的中断处理函数的地址，处理完以后回到刚刚保存的现场。 其实这个过程，本质上就是协程的核心流程了。是不是觉得很熟悉？这不就是调用函数的call/return嘛，但这是一种和call/return不同的逻辑路径跳转方式 区别是基于call/return方式系统进入处理函数，被调用函数会继续使用调用函数的context就是栈，返回的时候就会释放栈资源 而基于中断的方式，发起方和处理方可以使用自己的context，系统通过中断的方法来达到提供系统服务的目的 一个很重要的原因就是可以保障在很多情况下，都能让系统处理函数至少能有一个可用的context（属于系统的资源），这样当用户进程的context资源耗尽的情况下，也能调用一些系统服务 假设调用 go func(1,2,3) ，func函数会在一个新的go线程中运行，显然新的goroutine不能和当前go线程用同一个栈，否则会相互覆盖。所以对go关键字的调用协议与普通函数调用是不同的。不像常规的C语言调用是push参数后直接call func，上面代码汇编之后会是： 参数 push func push 12 call runtime.newproc pop pop 12是参数占用的大小。在runtime.newproc中，会新建一个栈空间，将栈参数的12个字节拷贝到新栈空间并让栈指针指向参数。 这时的线程状态有点像当被调度器剥夺CPU后一样，pc,sp会被存到类型于类似于进程控制块的一个结构体struct G内。 func被存放在了struct G的entry域，后面进行调度时调度器会让goroutine从func开始执行。 defer关键字调用过程类似于go，不同的是call的是runtime.deferproc,函数返回时，如果其中包含了defer语句，不是调用add xx SP, return,而是call runtime.deferreturn，add 48 sp，return 可以说，协程与线程主要区别是它将不再被内核调度，而是交给了程序自己，而线程是将自己交给内核调度 所以也不难理解golang中调度器的存在。 所以我们可以看出，协程的概念并不是与线程对应的，应该说和函数调用 call/return对应（也不难理解为什么会把golang中的goroutine当作一个以函数为单位的执行单元）。 它们的区别在于协程允许一个函数有多个入口、出口（逻辑上的），并且在切换到另一个函数执行时，允许使用一个新的context(包括调用栈）。正是有了这个机制基础，再加上CPU支持了保护模式，操作系统就可以接着实现进程、线程了。 进程和线程 协程明白了原理，进程和线程就更好理解了。 我觉得进程与线程其实最核心的是隔离与并行。 进程可看作为分配资源的基本单位，比如你new出了一块内存，就是操作系统将一块物理内存映射到你的进程地址空间上（进程创建必须分配一个完整的独立地址空间），这块内存就属于这个进程，进程内的所有线程都可以访问这块内存，其他进程就访问不了，其他类型的资源也是同理。 所以进程是分配资源的基本单位，也是我们说的隔离。 线程作为独立运行和独立调度的基本单位，进而我们可以认为线程是进程的一个执行流，独立执行它自己的程序代码。 线程上下文一般只包含CPU上下文及其他的线程管理信息，线程创建的开销主要取决于为线程堆栈的建立而分配内存的开销，这些开销并不大。 线程还分为系统级别和用户级线程，用户级别线程对引起阻塞的系统调用的调用会立即阻塞该线程所属的整个进程，而内核实现线程则会导致线程上下文切换的开销跟进程一样大，所以经常的折中的方法是轻量级进程（Lightweight）。 在 Linux 中，一个线程组基本上就是实现了多线程应用的一组轻量级进程。 线程的作用就在于充分使用硬件CPU，也就是我们说的并行。 goroutine 从我们应用角度来说，我们一般将协程理解为用户态轻量级线程，是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户的程序自己调度的。 因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的CPU控制权切换到其他进程/线程，通常只能进行协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。 但我们以上说的协程和golang中的协程是不一样的。 就像开头说的很多人将go的协程理解为我们常说的协程，但深究它们的名称不难看出，一个是goroutine，另一个是Coroutine，是不一样的。 golang语言作者Rob Pike也说， Goroutine是一个与其他goroutines 并发运行在同一地址空间的Go函数或方法。一个运行的程序由一个或更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine。 Go 协程意味着并行，协程一般来说不是这样的 Go 协程通过通道来通信,而协程通过让出和恢复操作来通信 而且Go 协程比协程更强大。因为Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理 也就是Golang 有自己的调度器，工作方式基本上是协作式，而不是抢占式，但也不是完全的协作式调度 例如在系统调用的函数入口处会有抢占。当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是我们为什么说 Golang 从语言层面支持了协程。 简单的说就是golang自己实现了协程并叫做goroutine。 Go中的进程和线程 在golang中进程和线程概念基本和我们常说的一致，大多调用系统的API实现 例如os 包及其子包 os/exec 提供了创建进程的方法 在 Unix 中，创建一个进程，通过系统调用 fork 实现（及其一些变种，如 vfork、clone） 在windows中通过系统调用CreateProcess等。 相信熟悉golang的都用过GOMAXPROCS，很多人都简单地理解为这个是限制进程数量，这样理解显然不仅是望文生义还有就是对进程和线程理解不够，官方解释就很准确： GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously。很清楚，就是限制cpu数，限制cpu数，本质上是什么，就是限制并行数，并行数即同时执行数量，执行单元即线程，即限制最大并行线程数量。 goroutine优势 goroutine的优势在于并行和非常低的资源使用 体现在内存消耗方面和切换(调度)开销方面 每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少，只有2KB，而线程则需要8MB 线程切换涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等 而goroutine 只有三个寄存器的值修改 - PC / SP / DX。 Go runtime的调度器 在了解Go的运行时的scheduler之前，需要先了解为什么需要它，因为我们可能会想，OS内核不是已经有一个线程scheduler了嘛？ 熟悉POSIX API的人都知道，POSIX的方案在很大程度上是对Unix process进场模型的一个逻辑描述和扩展，两者有很多相似的地方。 Thread有自己的信号掩码，CPU affinity等。但是很多特征对于Go程序来说都是累赘。 尤其是context上下文切换的耗时。另一个原因是Go的垃圾回收需要所有的goroutine停止，使得内存在一个一致的状态。垃圾回收的时间点是不确定的，如果依靠OS自身的scheduler来调度，那么会有大量的线程需要停止工作。 单独的开发一个GO得调度器，可以是其知道在什么时候内存状态是一致的，也就是说，当开始垃圾回收时，运行时只需要为当时正在CPU核上运行的那个线程等待即可，而不是等待所有的线程。 用户空间线程和内核空间线程之间的映射关系有：N:1,1:1和M:N N:1是说，多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核。 1：1是说，一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢。 M:N是说，多个goroutine在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。 Go的调度器内部有三个重要的结构：M，P，G。 M:代表真正的内核OS线程，和POSIX里的thread差不多，真正干活的人 G:代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。 P:代表调度的上下文，可以把它看做一个局部的调度器，使go代码在一个线程上跑，它是实现从N:1到N:M映射的关键。 图中看，有2个物理线程M，每一个M都拥有一个context（P），每一个也都有一个正在运行的goroutine。 P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。 图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue） Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行。 为何要维护多个上下文P？因为当一个OS线程被阻塞时，P可以转而投奔另一个OS线程！图中看到，当一个OS线程M0陷入阻塞时，P转而在OS线程M1上运行。调度器保证有足够的线程来运行所以的context P。 图中的M1可能是被创建，或者从线程缓存中取出。 当MO返回时，它必须尝试取得一个context P来运行goroutine，一般情况下，它会从其他的OS线程那里steal偷一个context过来 如果没有偷到的话，它就把goroutine放在一个global runqueue里，然后自己就去睡大觉了（放入线程缓存里）。Contexts们也会周期性的检查global runqueue，否则global runqueue上的goroutine永远无法执行。 另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了一个上下文P闲着没事儿干而系统却任然忙碌。 但是如果global runqueue没有任务G了，那么P就不得不从其他的上下文P那里拿一些G来执行。 一般来说，如果上下文P从其他的上下文P那里要偷一个任务的话，一般就‘偷’run queue的一半，这就确保了每个OS线程都能充分的使用。 总结 进程：分配资源的基本单位，独立的栈空间，独立的堆空间，进程之间调度由os完成 线程：独立运行和独立调度的基本单位，独立的栈空间，共享堆空间，内核线程之间调度由os完成 协程：用户级线程，独立的栈空间，共享堆空间，调度由用户自己控制，协作式调度，主动转让控制权 goroutine：Golang自己实现的协程，不完全协作式调度，由go自己实现的调度器调度。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime安装及使用]]></title>
    <url>%2F2018%2F11%2F08%2Fa0386001.html</url>
    <content type="text"><![CDATA[简介 Sublime Text是一个很好用的编辑器，记录一下安装过程还有各种插件 正文windows 安装进入官网Sublime Text直接点DOWNLOAD FOR WINDOWS，下载安装程序按提示安装就可以了 激活怎么说呢，还是建议大家有能力的话去支持一下作者，但我还是掏不起80刀，所以找找激活的办法，其实就算不激活也没什么，就是会在保存的时候出现弹窗直接给出链接SUBLIME TEXT 2.X, 3.X UNIVERSAL LICENSE KEYS COLLECTION FOR WIN, MAC &amp; LIN此网址会按sublime版本给出激活码，别选错了，网站最后还给出了禁用sublime更新的方法，阅读没啥难度 安装Package Control想要安装插件自然得先安装Package Control还是给出链接INSTALLATION - Package Control因为安装Package Control的python程序会更新，所以该网站也给出了警告 WARNING: Please do not redistribute the install code via another website. It will change with every release. Instead, please link to this page. 所以还是自行点进去看吧 插件 ChineseLocalizations 汉化插件，没啥说的，看个人需求吧 Color Highlight github 显示颜色的插件 MarkdownEditing github Markdown编辑插件，我个人是修改了以下内容 12345&#123; "color_scheme": "Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme", //改成黑色主题，默认的主题简直闪瞎眼 "wrap_width": 120, //每行字符上限 "line_numbers": true, //显示行号&#125; IMESupport github 这个是国人大神fork出来的版本原插件是一个日本人开发的，只支持第三方输入法，用win10原版的输入法是不行的这个版本就可以，但不能直接从Package Control安装，需要从github上下载解压，扔到插件目录里去。 Browser Refresh github web开发比较有用，配置好了只需要按出自定义的快捷键就可以切换到浏览器并刷新网页，这样改个样式什么的就很方便的查看结果了不过有一点不好，windows下每次刷新都将焦点移动到浏览器，这样还是得切换回sublime]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux端口相关命令]]></title>
    <url>%2F2018%2F11%2F08%2Fa87e2ec0.html</url>
    <content type="text"><![CDATA[简介 在 Linux 或者类 Unix 中，我该如何检查某个端口是否被占用？我又该如何验证 Linux 服务器中有哪些端口处于监听状态？ 验证哪些端口在服务器的网络接口上处于监听状态是非常重要的。 你需要注意那些开放端口来检测网络入侵。除了网络入侵，为了排除故障，确认服务器上的某个端口是否被其他应用程序占用也是必要的。 比方说，你可能会在同一个系统中安装了 Apache 和 Nginx 服务器，所以了解是 Apache 还是 Nginx 占用了 # 80/443 TCP 端口真的很重要。 这篇快速教程会介绍使用 netstat 、 nmap 和 lsof 命令来检查端口使用信息并找出哪些程序正在使用这些端口。 声明 这篇文章其实是转载到我原博客的，但我当时忘了贴原文地址，所以这里就不放原文地址了，向原文作者表示歉意 还有，这篇文章里面的命令我也只用过几个，不保证其可用性，等我有时间挨个测一下 PS：推荐一个linux命令搜索站点，其中有linux常用命令的说明和选项解读，很有帮助 Linux搜索引擎 正文如何检查 Linux 中的程序和监听的端口 打开一个终端，如 shell 命令窗口。 运行以下任意一行命令： 123sudo lsof -i -P -n | grep LISTENsudo netstat -tulpn | grep LISTENsudo nmap -sTU -O IP地址 下面我们看看这些命令和它们的详细输出内容： 方式 1：lsof 命令123sudo lsof -i -P -nsudo lsof -i -P -n | grep LISTENdoas lsof -i -P -n | grep LISTEN ### OpenBSD 输出如下： 仔细看上面输出的最后一行： 1sshd 85379 root 3u IPv4 0xffff80000039e000 0t0 TCP 10.86.128.138:22 (LISTEN) sshd 是程序的名称 10.86.128.138 是 sshd 程序绑定 (LISTEN) 的 IP 地址 22 是被使用 (LISTEN) 的 TCP 端口 85379 是 sshd 任务的进程 ID (PID) 方式 2：netstat 命令你可以如下面所示使用 netstat 来检查监听的端口和程序。 Linux 中 netstat 语法 1netstat -tulpn | grep LISTEN FreeBSD/MacOS X 中 netstat 语法 12netstat -anp tcp | grep LISTENnetstat -anp udp | grep LISTEN OpenBSD 中 netstat 语法 12netstat -na -f inet | grep LISTENnetstat -nat | grep LISTEN 方式 3：nmap 命令语法如下： 123sudo nmap -sT -O localhostsudo nmap -sU -O 192.168.2.13 ### 列出打开的 UDP 端口sudo nmap -sT -O 192.168.2.13 ### 列出打开的 TCP 端口 示例输出如下： 你可以用一句命令合并 TCP/UDP 扫描： 1sudo nmap -sTU -O 192.168.2.13 赠品：对于 Windows 用户 在 windows 系统下可以使用下面的命令检查端口使用情况： 123netstat -bano | morenetstat -bano | grep LISTENINGnetstat -bano | findstr /R /C:"[LISTING]"]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>有坑要填</tag>
        <tag>linux</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派换源]]></title>
    <url>%2F2018%2F11%2F08%2F7977c7cd.html</url>
    <content type="text"><![CDATA[简介 树莓派Raspbian系统的官方源也太慢了，找了找，换个源果然顺畅了许多 正文修改Raspbian的软件源（阿里） /etc/apt/sources.list 123deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi# Uncomment line below then 'apt-get update' to enable 'apt-get source'deb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi 修改树莓派的软件源（中国科技大学） /etc/apt/sources.list.d/raspi.list 123deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui# Uncomment line below then 'apt-get update' to enable 'apt-get source'deb-src http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang安装及配置]]></title>
    <url>%2F2018%2F11%2F08%2F9b996dd5.html</url>
    <content type="text"><![CDATA[简介 发现golang出到1.11.2版本了，把版本升一下级，并对某些配置进行记录 声明 这里是golang的官网-&gt;golang.org 最新版本去这里找，教程也写得很明白，就是得翻墙，如果不想翻墙的就可以看我的文章 环境 系统：ubuntu14.04GOLANG:1.11.2 正文安装 这次我选用的安装方法是从源码构建GO1.11.2 下载go1.4-bootstrap-XXXXXXXX.tar.gz我下载的是这个版本go1.4-bootstrap-20171003.tar.gz 解压到$HOME/go1.4 安装 1234sudo apt update &amp;&amp; sudo apt install gcc -y //没有安装gcc的先安装一下，构建需要chmod 777 -R go1.4cd go1.4/src/sudo CGO_ENABLED=0 ./make.bash 出现 Installed Go for XXX in /XXX/go1.4Installed commands in /XXX/go1.4/bin 即为成功 然后下载当前版本的go源码包我下载的是这个go1.11.2.src.tar.gz 解压 1sudo tar -C /usr/local -zxvf go1.11.2.src.tar.gz 6.安装 1234cd /usr/local/chmod 777 -R gocd go/src/sudo ./all.bash 出现 ##### API checkGo version is “go1.11.2”, ignoring -next /usr/local/go/api/next.txt ALL TESTS PASSED---Installed Go for linux/amd64 in /usr/local/goInstalled commands in /usr/local/go/bin*** You need to add /usr/local/go/bin to your PATH. 即为成功安装 配置 配置的话我一般分为两套配置，一套是root用户的，一套是普通用户的，主要区别就是，root用户可以直接监听80等端口，所以可以直接go run xxx.go，GOBIN可以直接放在/usr/local目录下，普通用户得老老实实的先build，然后再运行。 ROOT用户 1234export GOBIN=/usr/local/go/binexport PATH=$PATH:$GOBINexport GOPATH=$HOME/gowork #GOPATH就看个人喜好了export GOROOT=/usr/local/go 普通用户 1234export GOBIN=$HOME/gowork/bin #GOBIN就看个人喜好了export PATH=$PATH:$GOBIN:/usr/local/go/binexport GOPATH=$HOME/gowork #GOPATH就看个人喜好了export GOROOT=/usr/local/go 测试 运行Hello World 123456789package mainimport ( "log")func main() &#123; log.Println("hello world")&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲来无事的阅读（持续更新）]]></title>
    <url>%2F2018%2F11%2F01%2Fd014d56d.html</url>
    <content type="text"><![CDATA[简介 此文算是一些书签吧，全是链接，有的是从阮一峰老师的每周分享中看来的，没时间看，先扔在这，等有时间了，再来拜读，有的就是查资料的时候找到的，觉得不错，分享给大家。 正文 Why Kubernetes is The New Application Server 深入理解flutter的编译原理与优化 Julia 1.0 A Detailed Look at RFC 8446 (a.k.a. TLS 1.3) Face detection - An overview and comparison of different solutions Top 25 Programming Puzzles and Brain Teasers]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
        <tag>休闲读物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVS内网穿透测试]]></title>
    <url>%2F2018%2F11%2F01%2F27ece4b2.html</url>
    <content type="text"><![CDATA[简介 给朋友家用树莓派做了一个小web页，用来让他在外边用手机访问家里的移动硬盘，但是发现他家的光猫wan口虽然是公网IP，但却没有端口映射/DMZ功能，就想找找内网穿透的方案，花生壳之前用过，垃圾的一比，又得花钱，作为一个程序员，怎么能用这么low的方案呢？ 找来找去，内网穿透的开源方案倒是不少（如ngrok，frp等），但都有性能瓶颈，也就是说： 如果在光猫可以正常映射的情况下，直接访问家里的服务器，理论带宽应该为家中网络的上传带宽而如果用内网穿透，理论带宽就是公网服务器的上传带宽 再加上国内的服务器带宽实在太贵，所以想找个合适的方案，最终看到了lvs/tun模式，理论上讲，lvs搭配ddns，应该能实现我想要的功能，所以折腾一下，哪怕不成功，记录一下失败的原因也好。 lvs一般是作为负载均衡服务来使用的，但我看了看它的TUN模式，就是IP隧道模式，这个模式提到了三角通信的概念，就是说， 用户将请求发到公网服务器，经过服务器封装，发到业务服务器(这里的业务服务器就是家中的树莓派)业务服务器收到请求，将响应直接发送给用户 这样做的好处就是：公网服务器只作为转发请求的通道，而请求数据一般都不会太大，1M的小水管感觉就够了，而响应则是家里的树莓派发出，无需走公网服务器，这样的话，理论带宽就是家中的上传带宽，很完美不是么。 声明 此文参考了以下内容 负载均衡之LVS TUN模式（IP隧道） 10. LVS: You can’t map (or rewrite) ports with LVS-DR, LVS-Tun or localnode (but you can with iptables) LVS TUN LVS负载均衡之LVS-TUN实例部署（案例篇） LVS-TUN(Virtual Server via IP Tunneling)原理说明与配置用例 LVS负载均衡之基本介绍（介绍篇） 使用LVS+TUN搭建集群实现负载均衡 感谢以上作者提供的帮助，想看原文请自行跳转]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>有坑要填</tag>
        <tag>lvs</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[go101笔记]基本概念]]></title>
    <url>%2F2018%2F10%2F12%2F9270eef0.html</url>
    <content type="text"><![CDATA[简介 看到一本还不错的书，go101，觉得不错，整理一下，做个笔记 声明 本文大部分内容来自go101，由本文作者翻译，摘取整理。 想看英文原版的请自行跳转 正文类型 Go支持以下内置基本类型： 一种内置布尔类型：bool 十一种内置整数类型：int8，uint8，int16， uint16，int32，uint32， int64，uint64，int，uint，uintptr 两种内置浮点数类型：float32和float64 两种内置复数类型：complex64和complex128 一种内置字符串类型：string Go还支持两种别名类型 byte：uint8的别名 rune：int32的别名 int和uint值取决于操作系统，32位系统int就是4字节，64位系统int就是8字节 complex64实部和虚部都是float32，complex128实部和虚部都是float64 常量常量声明中的自动完成 以下代码 123456789const ( X float32 = 3.14 Y // 只能有一个标识符 Z // 只能有一个标识符 A, B = "Go", "language" C, _ // 需要“_”进行占位) 等同于 12345678const ( X float32 = 3.14 Y float32 = 3.14 Z float32 = 3.14 A, B = "Go", "language" C, _ = "Go", "language" ) iota 先放一个示例，了解一下编译时会发生什么 1234567891011121314151617181920212223242526272829package mainfunc main() &#123; const ( k = 3 // now, iota == 0 m float32 = iota + 0.1 // m float32 = 1 + 0.1 n // n float32 = 2 + 0.1 p = 9 // now, iota == 3 q = iota * 2 // q = 4 * 2 _ // _ = 5 * 2 r // r = 6 * 2 s, t = iota, iota // s, t = 7, 7 u, v // u, v = 8, 8 _, w // _, w = 9, 9 ) const x = iota // x = 0 const ( y = iota // y = 0 z // z = 1 ) println(m, n) // +1.100000e+000 +2.100000e+000 println(q, r) // 8 12 println(s, t, u, v, w) // 7 7 8 8 9 println(x, y, z) // 0 0 1&#125; 正式使用时，应该使用的更有意义，如： 1234567891011const ( Failed = iota - 1 // == -1 Unknown // == 0 Succeeded // == 1)const ( Readable = 1 &lt;&lt; iota // == 1 Writable // == 2 Executable // == 4) 变量包级变量的依赖关系影响其初始化顺序 对于以下示例 12var x, y = a+1, 5 // 8 5var a, b, c = b+1, c+1, y // 7 6 5 8 包级变量的初始化顺序是y = 5，c = y，b = c+1，a = b+1，x = a+1]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go101</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seafile Terminal客户端同步间隔设置开机自启教程]]></title>
    <url>%2F2018%2F10%2F12%2F47c0a75d.html</url>
    <content type="text"><![CDATA[简介 因为我个人的怪癖，代码喜欢实时同步到服务器上去让它自己热编译 所以想找找看多端同步的开源软件，之前是用nextCloud 但发现它多端同步的时候不是增量上传，导致同步速度极慢 我这暴脾气，果断换了seafile 但在使用的时候，发现seafile的Terminal客户端不是自动开机自启的，每次重启还要执行seaf-cli start启动守护线程，很麻烦，官网文档又没给ubuntu14.04开机自启的解决方案 所以自行搜索调试，最后解决了此问题，在此记录一下。 环境 系统：ubuntu 14.04时间：2018-10seafile server：6.1.8 安装&amp;配置 seafile服务器端没啥好说的，用的是seafile官方文档-Linux 下部署 Seafile 服务器中提供的Seafile 安装脚本 下载了专业版的包（需要去Seafile用户中心注册下载） 然后跟着安装脚本走就行了。 Terminal客户端的配置参考Install Seafile Client on Linux和Seafile client for a Cli server都不难，就几条命令 开机自启 如果你的服务器运行systemd（ubuntu15.04及以上）,就可以用官方文档-开机自启动 Seafile的解决方案，不过我没试过，不知道好用不好用。 因为我服务器系统版本是ubuntu14.04，不支持systemd，所以用以下方案，参考了Seafile Terminal Client - Installation und Synchronisation unter Ubuntu 14.04.x LTS 首先，创建一个开机脚本 1nano /usr/local/bin/seafile-client-starter.sh 写入以下内容，注意seaf-cli的路径别写错了 123#!/bin/shset -e/usr/bin/seaf-cli start 退出，加个执行权限 1chmod +x /usr/local/bin/seafile-client-starter.sh 开个crontab 1crontab -e 写入以下内容，意思是重启后等10秒，让系统网络啊什么的正常工作，然后运行seafile开机脚本，根据自己的情况调整等待时间。我这服务器10秒就够了。 1@reboot sleep 10 &amp;&amp; /bin/sh /usr/local/bin/seafile-client-starter.sh 2&gt;&amp;1 &gt; /var/log/cron.log 重启就行了，运行seaf-cli status看看同步正不正常。 调整同步间隔 其实不设置也没啥事，同步间隔也能接受，不过GUI客户端能设置，Terminal客户端就也要设置一下才甘心 参考了这个 打开seafile目录下的seafile-data/repo.db 1sqlite3 ~/seafile-client/seafile-data/repo.db 执行以下内容，$repo-id替换为你资料库的id，$time替换为你想设置的间隔 1INSERT INTO "RepoProperty" VALUES ('$repo-id','sync-interval','$time'); 退出，重启seaf-cli]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>seafile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Local Search 搜索出来的URL不正确的解决办法]]></title>
    <url>%2F2018%2F10%2F12%2Ff0bee745.html</url>
    <content type="text"><![CDATA[简介 突然发现此博客的搜索功能不正常了，解决一下。 环境 hexo nexT主题 Local Search 配置 根据nexT文档-搜索服务配置 BUG 点击侧边栏搜索 搜索任意字符 点击任意搜索结果预期结果：跳转到相应文章页面，页面URL应为https://xxxx.qithub.io/2018/01/01/xxx.html显示结果：无法跳转到相应页面,页面的URL为http://0.0.7.226/01/01/xxx.html 调试 走了许多弯路，搜了半天的0.0.7.226,费了很长时间，结果发现是hexo-generator-searchdb生成的search.xml中，文章的URL不对，在编码之后，文章的URL应该是下面这样的： %2F2018%2F01%2F01%2Fxxx.html 但实际上却生成了这样的 %2F%2F2018%2F01%2F01%2Fxxx.html 多了一个%2F，也就是说，在URL解码之后，多了一个/ 但我没仔细想，为什么//2018在innerHTML的时候会变成http://0.0.7.226，应该是一些莫名其妙的转换吧，如果有知道的大佬请告知我原因。 看了一下hexo-generator-searchdb作者的issues，也没发现有别人出现这种问题，想了一下，应该是此插件和hexo-abbrlink插件同时使用的原因，生成静态网页的时候多加了一个/ 解决方案 因为我也没用过nodejs，所以就暴力解决一下 在node_modules/hexo-generator-searchdb/目录下，搜索url字段 应该有以下几个文件是需要修改的 json_generator.jsxml_generator.jsxml.ejs 把搜出来的那行中，config.root都删掉，比如xml_generator.js文件中，相关代码是这样的 12345678 var xml = template(&#123; config: config, posts: posts, pages: pages, raw: raw, limit: searchlimit, feed_url: config.root + searchConfig.path&#125;); 改为 12345678 var xml = template(&#123; config: config, posts: posts, pages: pages, raw: raw, limit: searchlimit, feed_url: searchConfig.path&#125;); 重新生成hexo g，查看搜索结果，应该就可以正常使用了。 后记 我大概看了一下，这个config.root，大概率就是_config.yml文件中的那个root项，但是全局搜索了一下config.root这个字段，有多个插件在用，也就没有继续调试的兴趣了，做一条只知其然的咸鱼罢。 如果有大佬有更好的解决方案，请务必告知我，我将不胜感激！]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>Local Search</tag>
        <tag>hexo</tag>
        <tag>nexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor使用]]></title>
    <url>%2F2018%2F08%2F30%2Fdf65bfe9.html</url>
    <content type="text"><![CDATA[简介 推荐一个好用的进程管理程序，再也不用坑爹的screen跑程序了。 先放官方介绍：supervisor介绍（英） 总结一下： Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。 它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在Supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。 声明 本文根据以下博客部分观点加上作者自己的一点看法汇聚而成，感谢这些作者。 进程管理supervisor的简单说明 Supervisor的作用与配置 supervisor(一)基础篇 环境 系统：ubuntu 14.04supervisor：3.0b2时间：2018-8 安装 ubuntu/debian1apt install supervisor -y centos1yum install supervisor 配置 子进程配置一般情况下，supervisor本身是不用配置的，在/etc/supervisor/conf.d/新增一个子进程的配置文件xxx.conf，并reload一下supervisorctl就可以了。以下是配置文件常用选项模板。 12345678[program:XXX]command=XXX #脚本执行命令（命令不能为守护进程）directory=XXX #脚本目录stdout_logfile=/var/log/XXX.log #日志输出redirect_stderr=true #把 stderr 重定向到 stdout，默认 falseautostart=true #supervisor启动的时候是否随着同时启动，默认Trueautorestart=true #当程序exit的时候，这个program不会自动重启,默认unexpectedstdout_logfile_maxbytes=10MB #stdout 日志文件大小，默认 50MB 详细配置说明： 选项 简介 默认 必填 描述 [program:xxx] 子进程名称 无 是 这个就是咱们要管理的子进程了，:后面的是名字，最好别乱写和实际进程，有点关联最好。这样的program我们可以设置一个或多个，一个program就是要被管理的一个进程 command 脚本执行命令 无 是 这个就是我们的要启动进程的命令路径了，可以带参数例子：/home/test.py -a &#39;hehe&#39;有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是守护进程。这个想想也知道了，比如说command=service httpd start。httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令这已经不是严格意义的子进程了。 process_name=%(program_name)s 进程名 子进程名称 否 如果我们下面的numprocs参数为1的话，就不用管这个参数了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字，但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个进程都用同一个进程名吧。 numprocs 启动进程的数目 1 否 当不为1时，就是进程池的概念 directory 运行目录 无 否 进程运行前，会前切换到这个目录 umask 进程掩码 none 否 进程掩码 priority 子进程启动关闭优先级 999 否 优先级低的，最先启动，关闭的时候最后关闭 autostart 自启动 true 否 子进程将在supervisord启动后被自动启动 autorestart 自动重启 unexpected 否 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动.如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无条件的重启 startsecs 启动等待 1 否 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了 startretries 尝试启动次数 3 否 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把此进程的状态置为FAIL exitcodes 退出码 无 否 和上面的的autorestart=unexpected对应。。exitcodes里面的定义的退出码是expected的 stopsignal 进程停止信号 TERM 否 以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号，当用设定的信号去干掉进程，退出码会被认为是expected stopwaitsecs 停止信号等待时间 10 否 当我们向子进程发送stopsignal信号后，到系统返回信息给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该子进程发送一个强制kill的信号。 stopasgroup 停止进程组 false 否 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。需要注意的是，该选项发送的是stop信号 killasgroup 结束进程组 false 否 这个和上面的stopasgroup类似，不过发送的是kill信号 user 用户 无 否 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来管理该program redirect_stderr err重定向 false 否 如果为true，则stderr的日志会被写入stdout日志文件中 stdout_logfile 日志路径 无 否 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被清空。当 redirect_stderr=true的时候，sterr也会写进这个日志文件 stdout_logfile_maxbytes 日志文件最大大小 50 否 日志文件最大大小 stdout_logfile_backups 日志文件备份数 10 否 日志文件备份数 stdout_capture_maxbytes capture管道的大小 0 否 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout发送信息，而supervisor可以根据信息，发送相应的event。默认为0，为0的时候表达关闭管道 stdout_events_enabled 触发event false 否 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将触发supervisord发送PROCESS_LOG_STDOUT类型的event stderr_logfile stderr日志路径 AUTO 否 这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中默认为AUTO，也就是随便找个地存，supervisord重启被清空 stderr_logfile_maxbytesstderr_logfile_backupsstderr_capture_maxbytesstderr_events_enabled stderr选项 无 否 和stdout一样，就不详细说明了 environment 环境变量 无 否 这个是该子进程的环境变量，和别的子进程是不共享的 supervisor配置不过有的时候我们需要更改一些supervisor本身的配置，稍微解释下。安装完成后默认的配置是这样的 /etc/supervisor/supervisord.conf 12345678910111213141516171819202122232425262728; supervisor config file[unix_http_server]file=/var/run/supervisor.sock ; (the path to the socket file)chmod=0700 ; sockef file mode (default 0700)[supervisord]logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir=/var/log/supervisor ; ('AUTO' child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL for a unix socket; The [include] section can just contain the "files" setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.[include]files = /etc/supervisor/conf.d/*.conf 找不到这个文件用一下命令生成 1echo_supervisord_conf &gt; /etc/supervisord.conf [unix_http_server]这部分设置HTTP服务器监听的UNIX domain socket file: 指向UNIX domain socket，即file=/var/run/supervisor.sock chmod：启动时改变supervisor.sock的权限 [supervisord]与supervisord有关的全局配置需要在这部分设置 logfile: 指向记录supervisord进程的log文件 pidfile：pidfile保存子进程的路径 childlogdir：子进程log目录设为AUTO的log目录 [supervisorctl] serverurl：进入supervisord的URL， 对于UNIX domain sockets, 应设为 unix:///absolute/path/to/file.sock [rpcinterface:supervisor]这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这个选项必须要开启的 [include]如果配置文件包含该部分，则该部分必须包含一个files键 files：包含一个或多个文件，这里包含了/etc/supervisor/conf.d/目录下所有的.conf文件，可以在该目录下增加我们自己的配置文件，在该配置文件中增加[program:x]部分，用来运行我们自己的程序 还有一些高级选项我没试过，但找到了相关博客，先放上来，等试过了再写写 supervisor(一)基础篇supervisor(二)eventsupervisor(三)xml_rpc 控制两种方式控制supervisor，进入supervisor面板，或者直接运行命令 进入superviosrctl 1supervisorctl 常用指令 12345678910help [xxx] #不带参数为查看所有命令，带参数就是详解start xxx #启动某个子进程stop xxx #停止某个子进程restart xxx #重启某个子进程status #查看所有子进程状态reload #重启supervisordadd #更新配置？好像是，不确定。clear #清除日志start/stop/restart... all #对所有子进程进行操作 剩下的我感觉不太常用，以下是全部指令 12 add clear fg open quit remove restart start stop update avail exit maintail pid reload reread shutdown status tail version 用到的时候再去查吧。 直接运行指令1supervisorctl xxx #xxx为上面的常用指令]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCP评测]]></title>
    <url>%2F2018%2F08%2F30%2Ffcd14a5a.html</url>
    <content type="text"><![CDATA[简介 忘了什么时候开了Google Cloud Platform的免费赠金，$300，一年的有效期，我记得之前领赠金的时候开了一两个实例测了一下，发现太垃圾，到中国大陆的流量又是另收费，就删了没管，但这两天突然想起来了，赠金还剩下200多，不能浪费，开几个实例测一下，顺带水一篇。 先来吐槽一下 GCP控制台要翻墙！翻墙！翻墙！体验极差，之前搬瓦工被墙了都特意开个中国站，google竟然就让他一直墙着，感受到来自GFW和google深深的恶意。 屎一样的IO本来我觉得阿里云/腾讯云那种300多一年vps的IO已经够垃圾的了，但也没办法，谁叫人家在国内呢，但你GCP连人家的一半都比不上（修正：比阿里云的一半多，但也有限，和腾讯云的差不多T。T—对不起！），换了SSD也一样，甚至还不如普通硬盘，就有点过分了吧，搬瓦工年付19.9刀的vps，IO是你的5倍都不止，扎心了我的google。 正经的评测 创建了3个实例，分别位于东京，台湾，洛杉矶 bench.sh 使用bench.sh 1wget -qO- bench.sh | bash 东京 洛杉矶 台湾 怎么说呢，勉勉强强ping–chinazchinaz–ping检测 东京 洛杉矶 台湾 ping–ipip.netipip.net–ping检测 东京 洛杉矶 台湾 网页挂了个hello world。 东京 洛杉矶 台湾 总结主要是流量收钱，没有赠金的情况下，很容易出问题，总体来讲不推荐。]]></content>
      <categories>
        <category>评测</category>
      </categories>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang WebAssembly Demo]]></title>
    <url>%2F2018%2F08%2F28%2Fd529857f.html</url>
    <content type="text"><![CDATA[简介闲来无事，跑个Golang版的WebAssembly，关于WebAssembly的介绍点以下链接 WebAssembly 现状与实战]]></content>
      <categories>
        <category>Demo</category>
      </categories>
      <tags>
        <tag>有坑要填</tag>
        <tag>golang</tag>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】用Live555中的openRTSP保存H264]]></title>
    <url>%2F2018%2F08%2F21%2F2e389ee7.html</url>
    <content type="text"><![CDATA[简介 这两天抽空整理书签，发现有一篇以前做监控时踩坑的文章，转过来留档。 声明 本文转载自用Live555 中的openRTSP 保存H264 想看原文请自行跳转 以下为原文(修复了一些笔误并稍稍美化) 用Live555中的openRTSP保存H264文件很简单 但是发现保存的H264文件并不能直接被VLC播放 同一个RTSP源 用VLC保存的H264文件就可以直接被播放 经过研究 发现是openRTSP没有把SDP中已经包括的SPS &amp;PPS数据保存到文件中 将VLC保存的H264文件的前2个00 00 00 01数据 也就是SPS &amp;PPS复制到openRTSP保存的文件最前头就可以播放了 123456789101112131415 &#125; else if (strcmp(subsession-&gt;mediumName(), "video") == 0 &amp;&amp; (strcmp(subsession-&gt;codecName(), "H264") == 0)) &#123; // For H.264 video stream, we use a special sink that insert start_codes: unsigned int num=0; SPropRecord * sps=parseSPropParameterSets(subsession-&gt;fmtp_spropparametersets(),num); fileSink = H264VideoFileSink::createNew(*env, outFileName, fileSinkBufferSize, oneFilePerFrame); struct timeval tv=&#123;0,0&#125;; unsigned char start_code[4] = &#123;0x00, 0x00, 0x00, 0x01&#125;; fileSink-&gt; addData(start_code, 4, tv); fileSink-&gt;addData(sps[0].sPropBytes,sps[0].sPropLength,tv); fileSink-&gt; addData(start_code, 4, tv); fileSink-&gt;addData(sps[1].sPropBytes,sps[1].sPropLength,tv); delete[] sps;&#125; else &#123;]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>live555</tag>
        <tag>openRTSP</tag>
        <tag>H264</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MP4文件格式解析]]></title>
    <url>%2F2018%2F08%2F21%2F86ee662b.html</url>
    <content type="text"><![CDATA[简介 这两天抽空整理书签，发现有几篇以前做监控时收藏的文章，就稍微整理一下，留档。 声明 本文根据以下博客部分观点加上作者自己的一点看法汇聚而成，感谢这些作者。 MP4文件格式的解析，以及MP4文件的分割算法 视频文件头解析–MP4 mp4文件格式解析（一） MP4文件格式简要解析 有坑要填 占坑]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>有坑要填</tag>
        <tag>MP4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPSEC AUTO详解]]></title>
    <url>%2F2018%2F08%2F21%2Fe8146f74.html</url>
    <content type="text"><![CDATA[简介 这两天抽空整理书签，发现CSDN上有一篇ipsec auto的参数说明，觉得不错，但他那种排版我有些接受不了，就稍微整理一下，留档。 声明 本文转载自CSDN上的一篇好文IPSEC_AUTO(8) － 控制IPsec连接，由本文作者整理。 想看原文的请自行跳转 有坑要填 占坑，我先把版本弄清楚，然后再来更新。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ipsec</tag>
        <tag>vpn</tag>
        <tag>有坑要填</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPSEC配置详解]]></title>
    <url>%2F2018%2F08%2F20%2Fcab61925.html</url>
    <content type="text"><![CDATA[简介 这两天抽空整理书签，发现CSDN上有一篇ipsec.conf的配置说明，觉得不错，但他那种排版我有些接受不了，就稍微整理一下，留档。 声明 本文转载自CSDN上的一篇好文IPSEC.CONF(5) － IPsec配置，英文原文IPSEC.CONF，由本文作者梳理。 想看原文的请自行跳转 补充声明 写到一半突然发现英文版原文和CSDN上的文章选项貌似不一致。。。懵了，因为是很久以前加的书签，也忘了当时用的那个版本了，所以以下内容看看就行了，不保证以下所有选项都可用（大部分应该还是可用的），等我有时间了啃一下英文版的，重新搭一个，再来补完这篇吧。估计没什么希望了，逃~。 放一个当前稳定版本（好像是2.06？）的英文文档链接IPSEC.CONF 正文 描述ipsec.conf指定了Openswan IPsec子系统的大多数配置和控制信息。 1include ipsec.*.conf 包含指定的配置文件 例子conn项定义了一个IPsec连接的规范，名字可以随意定义。例如： 12345678910conn snt left=10.11.11.1 leftsubnet=10.0.1.0/24 leftnexthop=172.16.55.66 leftsourceip=10.0.1.1 right=192.168.22.1 rightsubnet=10.0.2.0/24 rightnexthop=172.16.88.99 rightsourceip=10.0.2.1 keyingtries=%forever 连接选项（GENERAL） 选项 描述 参数 connaddrfamily 连接地址族 可用参数为ipv4（缺省）或者ipv6IPv6在openswan 2.4中的NETKEY支持和openswan 2.6.33中的KLIPS支持 type 连接类型 tunnel：隧道模式，用户的整个IP数据包被用来计算AH或ESP头，AH或ESP头以及ESP加密的用户数据被封装在一个新的IP数据包中。通常，隧道模式应用在两个安全网关之间的通讯。transport：传输模式，只是传输层数据被用来计算AH或ESP头，AH或ESP头以及ESP加密的用户数据被放置在原IP包头后面。通常，传输模式应用在两台主机之间的通讯，或一台主机和一个安全网关之间的通讯。 passthrough：表示不使用IPsecdrop:表示丢弃数据reject:表示丢弃数据并返回ICMP诊断包 left [必选项] 左侧设备公网接口IP地址 ip地址%defaultroute：如果 config setup 项中的 interfaces 包含 %defaultroute，那么left将自动由本地的缺省路由接口地址填充；leftnexthop也支持。%any：表示在协商时填充。%opportunistic：表示 left 和 lefnexthop 的参数从 left 侧客户端的DNS数据中获取。 leftsubnet 左侧设备的私有子网 格式为 network/netmask支持 vhost: 和 vnet: 这2个速记，语法与 virtual_private 相同 %priv 表示子网与 virtual_private相同 %no 表示没有子网 leftsubnets 指定左侧设备的多个私有子网 格式 {networkA/netmaskA,networkB/netmaskB,[..]}leftsubnet 和 leftsubnets 不能同时使用。 leftprotoport 指定隧道中允许的通过的协议和端口 参数可以是数字或者协议名（请在 /etc/protocols 中查找），例如 leftprotoport=icmp，或 protocol/port，如 tcp/smtp。ports可以使用数字或名字表示（请在 /etc/services 中查找）%any 表示所有的协议端口。 leftnexthop 左侧设备连接公网的下一跳网关IP地址 缺省为 %direct。如果这方法没有使用，则leftnexthop为 %defaultroute leftsourceip 连接中主机的IP地址 ip leftupdown 连接状态改变时的脚本 连接状态改变时， “updown”中的脚本调整路由和防火墙（缺省为 ipsec_updown） leftfirewall 不再使用此选项 不再使用此选项 连接选项（AUTOMATIC KEYING）下面所有项选自动生成key中起作用，在手动指定key中被忽略。 选项 描述 参数 auto IPsec启动时自动执行 现在支持的参数有 add （ipsec auto --add）route（ipsec auto --route）start（ipsec auto --up）manual（ipsec manual --up）ignore 表示不自动启动具体请看 config setup authby 2个安全网关之间的认证方法 secret:表示共享密钥rsasig:表示RSA数据签名（缺省）secret&#124;rsasig:同时使用 ike IKE第一阶段（ISAKMP SA）中的加密/认证算法 格式为 cipher-hash;modpgroup,cipher-hash;modpgroup,...。 例如：ike=3des-sha1,aes-sha1ike=aesike=aes128-md5;modp2048 ike=aes128-sha1;dh22ike=modp1536 算法值请查看 ipsec_spi(8)中的 –ike选项IKE组合形式： cipher: 3des or aes hash: sha1 or md5 pfsgroupt(DHgroup): modp1024 or modp1536 phase2 设置将产生的SA类型 esp用于加密（缺省），ah用于认证 phase2alg 第二阶段中支持的算法 算法之间用逗号分隔 esp 此选项不再使用 用phase2alg代替 ah 连接中的AH算法 算法格式请看 ipsec_spi(8)中的 –ah选项 ikev2 IKEv2（RFC4309）设置使用 never 或 no 表示不使用IKEv2propos 或 yes 表示允许使用IKEv2，同时缺省使用IKEv2进行协商insist:表示只接受IKEv2协商，IKEv1将被拒绝permit:缺省，表示不主动使用IKEv2，但对端使用IKEv2的话也接受 sareftrack XXXXXX XXXXXX leftid 左侧参加者的身份确认方法 可以是IP地址，域名%fromcert: 表示ID从证书的DN获取%none: 表示不使用ID值 leftrsasigkey 左侧RSA签名认证 格式使用RFC2537 ipsec_ttodata(3)编码%none:表示不指定值%dnsondemand: 表示值从DNS中获取当需要使用到此值时%dnsonload: 表示值从DNS中获取当读取ipsec.conf时(原文这么写的，扎心的翻译)%cert: 表示信息从 %leftcert 中获取 leftrsasigkey2 第2个公钥 leftcert X509证书 如果没有指定全路径，则从 /etc/ipsec.d/certs/ 目录中查找。如果opesnswan编译时指定了 USE_LIBNSS=true，那么openswan将会去NSS数据库中查找RSA key leftca CA 如果没有指定，那么将用 leftcert 中的证书认为是CA证书 leftsendcert openswan发送X509证书到远程主机的选项配置 yes&#124;always: 表示总是允许发送证书ifasked: 缺省,表示如果远程主机要求证书则进行发送no&#124;never: 表示从不发送证书 leftxauthserver 左侧为XAUH服务端 可以使用PAM认证或 /etc/ipsec.d/passwd中的MD5口令。对端必须配置为 rightxauthclient ，做为XAUTH客户端 leftxauthclient 左侧为XAUT客户端 xauth连接必须进行交互启动，不能使用配置 atuo=start。它必须使用命令行 ipsec auto --up conname leftxauthusername XAUTH认证中使用的用户名 XAUTH密码在 ipsec.secrets 文件中配置 leftmodecfgserver 左侧是模式配置服务端 它能下发网络配置到客户端。 参数为 yes 或 no （缺省） leftmodecfgclient 左侧是模式配置客户端 它能从服务端接收网络配置。参数为 yes 或 no （缺省） modecfgpull 从服务端接收模式配置信息 参数为 yes 或 no （缺省） modecfgdns1modecfgdns2modecfgwins1modecfgwins2 指定DNS、WINS的IP地址 remote_peer_type 设置远程主机类型 参数为 cisco 或 ietf nm_configured XXXX XXXX forceencaps RFC-3948封装 参数为 yes 或 no （缺省）。当forceencaps=yes时将强制使用RFC-3948封装（UPD端口4500包封闭ESP）。如果此选项打开，那么 nat_traveral=yes必须打开 overlapip XXXX XXXX dpddelay 主机探测延迟时间 缺省为30秒。如果此选项被设置，dpdtimeout也应该设置 dpdtimeout 主机探测超时时间（以秒为单位） 缺省为120秒。如果超时，将删除SA dpdaction 当PDP探测到主机死亡时要执行的动作 hold :（缺省）表示eroute将进入 %hold 状态clear: 表示eroute和SA都要清除restart: 表示SA将立即从协商restart_by_peer: 表示所有死亡主机的SA将进行从协商 pfs XXXX 参数为 yes（缺省） 或 no aggrmode 使用野蛮模式替换主模式 野蛮模式不安全，容易受到服务拒绝攻击 参数为 yes 或 no （缺省） salifetime SA存活时间 参数为数字+ s/m/h/d （缺省为8h，最大24h）“keylife“ “lifetime“ 是 “salifetime“ 的别名 rekey 当密钥到期后是否进行从协商 参数为 yes（缺省） 或 no rekeymargin 密钥到期前多长时间进行从协商 参数请看 salifetime （缺省9m） keyingtries 协商尝试次数 %forever: 表示从不放弃，一直进行协商 ikelifetime IKE存活时间 参数请看salifetime compress 是否进行压缩处理 参数为 yes 或 no （缺省） metric 设置ipsecX 或 mastX 接口的 metric 优先级 XXXX mtu 设置MTU XXXX disablearrivalcheck XXXX 参数为 yes 或 no （缺省） failureshunt 当协商失败时执行的动作 缺省为 nonepassthrough；drop；reject具体看选项 type 配置部分此部分包含了软件启动时所使用到的信息，例如：123456config setup interfaes="ipsec0=eth1 ipsec1=ppp0" klipsdebug=none plutodebug=control protostack=auto manualstart= 有坑要填]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ipsec</tag>
        <tag>vpn</tag>
        <tag>有坑要填</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用StyleUrl+Chrome修改CSS样式表]]></title>
    <url>%2F2018%2F08%2F20%2Fcf557117.html</url>
    <content type="text"><![CDATA[简介 我们有时会在 Chrome 浏览器的开发者工具里面，修改 CSS 样式表。这个浏览器插件会比较修改前后的样式表，生成 diff 文件，并存入 GitHub Gist。 声明 拜读阮一峰的网络日志-每周分享第 18 期后，觉得此插件很有意思，来推荐一下。 正文 安装在StyleUrl官网点击ADD TO CHROME即可完成安装，需梯子请自备。 使用 找一个网站这里用google试一下 打开工具打开开发者工具(F12)，并启用StyleUrl插件。 修改CSS样式随便改改CSS样式，这里把背景改成黄的。 查看改动并提交点击StyleUrl插件View changes-&gt;Create Gist 授权给StyleUrl授权创建Gist 完成Gist效果：]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仅限内部使用的FQ教程]]></title>
    <url>%2F2018%2F07%2F31%2Fc189fe6a.html</url>
    <content type="text"><![CDATA[准备阶段 首先，不认识我的可以别往下看了，看完了也翻不出去。 声明 再次重申，翻出去之后，不要干不正常的事情，连累到我大家都没得用。 正餐 先联系我，给你开放注册权限 万恶之源访问这里，界面是这样的： 注册点击注册 登录登录成功后自动创建账号，默认一年有效期，自注册日期之后，每个月200G的流量，到期了告诉我，我给你续上。 点击“账号” 下载客户端 windows 官方下载（保证最新，但有可能被墙） 或者下载这个 版本4.1.0的镜像 解压缩，放到你喜欢的位置（提醒：运行之后可能会生成大量文件，不建议放在桌面上） 安卓 官方下载（保证最新，但有可能被墙） 以下是相关的版本说明 armeabiv-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它.arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。universal: 不知道下哪个就用这个吧。。。。应该x86: 平板、模拟器用得比较多。 或者下载这个版本4.6.1镜像，下载下来是压缩包，解压之后选择对应版本传到手机上，安装即可。如果安卓版提示“必须更新Google Play服务才可以使用”之类的话，请往下看，最后有解决办法还有一种方法，用google play应用商店下载，自动适配版本，但推荐有google账号的人使用此方法，教程也在最后 导入配置 你一定发现了，在第三步中，账号页面中有一个二维码，现在我们点击它，弹窗如图： windows 把弹窗底部的链接复制，打开刚才下载解压的windows客户端，会在右下角状态栏显示一个小飞机的图标，右键选中小飞机。 服务器-&gt;从剪贴板导入URL，即可完成配置。 相关的安装选项我的个人建议：勾选“启用系统代理”，“开机启动”，“允许其他设备连入”，“系统代理模式”选为“PAC模式”，并且将pac更新到最新“PAC-&gt;从GFWList更新本地PAC”，这样的设置就可以国内的流量走本地网络，被墙的流量走软件，既省流量又简洁。 安卓 打开应用，点击右上角的加号，选择“扫描二维码”，扫描弹窗上的二维码 会自动增加一条配置（在没有配置的时候，软件会自动增加一条默认的配置，可点击配置上的编辑-&gt;删除进行删除），点击选中此配置，点击右下角小飞机，即可完成配置。 加餐 关于安卓版本客户端提示“必须更新Google Play服务才可以使用”的解决方案。 简直是让人震惊，本来就是用来FQ的工具，居然得先FQ更新才能使用，令人窒息的操作，下面给出不算优雅的解决方案。 首先，你得有一台配置完成的windows电脑，右键选中状态栏中的小飞机，勾选“允许其他设备连入”，然后记住此电脑的IP地址。 打开手机，连接到与电脑同一网段的网络（就是和电脑连接到同一个路由器）。 点开手机上的设置-WLAN，进入已连接WIFI的详情里 选项中有一个“代理”的选项，如图： 主机名填写电脑的IP，端口1080（1080是默认端口，没改过代理端口的应该都是这个），点击确定，你会发现你可以上google了，也就是说可以更新了，更新完就可以正常使用了。 软件正常使用之后别忘了把代理删了。 安卓版本客户端使用google play应用商店下载的方法 首先得把上面那条加餐做完，就是说配置上代理之后，点击这里进行下载。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>ss</tag>
        <tag>内部</tag>
      </tags>
  </entry>
</search>
